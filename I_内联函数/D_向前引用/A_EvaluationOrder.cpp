//
// Created by 何时夕 on 2017/12/26.
//
class Forward {
    int i;
public:
    Forward() : i(0) {}
    // 只有在类声明完毕之后 内联函数才会被计算 所以可以在g() 声明之前调用g()
    int f() const {
        return g() + 1;
    }
    int g() const {
        return i;
    }
};
/**
 * 1.编译器会将任何函数的 函数类型 放入 符号表中，但是内联函数还会讲其函数体放入 符号表中。
 * 2.编译器在调用到一个内联函数的时候，首先会像检查普通函数那样检查一个 内联函数，然后如果检查通过了
 * 那么就将函数体替换到当前函数调用，这样就减少了函数调用的开销，当然这里的替换不是死板的替换。
 * 3.有两种情况编译器不能执行函数的内联，此时内联函数就退化成普通函数了
 *      1.函数太复杂，比如任何种类的循环都被认为太复杂，还有就是调用函数的开销远小于函数体执行的开销。
 *      需要记住的是 每次执行一个大内联函数，相应的函数体代码就会被插入到函数调用的地方，这样会使得代码膨胀
 *      2.需要显式或者隐式取函数地址，这样编译器也不能执行内联，因为内联函数是没有 函数地址的。
 */

