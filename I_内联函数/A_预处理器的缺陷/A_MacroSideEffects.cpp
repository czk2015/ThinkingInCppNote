//
// Created by 何时夕 on 2017/12/24.
//
#include <iostream>
#include <fstream>
using namespace std;

/**
 * 宏是由预处理器处理的，而代码是由编译器处理的，很容易将宏看做一个函数，所以宏会出现几个问题：
 * 1.如果空格处理不当 会造成宏展开错误
 * 2.表达式在宏内优先级展开不正确
 */

//1.如果空格处理不当 会造成宏展开错误
#define F (x) (x + 1)

void callF() {
//    F(1);
    /*
     * 这里会展开成 这样:(x) (x + 1)(1) 导致编译错误
     * 而不是我们期望的这样:(1 + 1)
     */
}

//2.表达式在宏内优先级展开不正确
#define FLOOP(x , b) x >=b ? 0 : 1

void callFLOOP() {
    int a = 0;
    if(FLOOP(a & 0x0f , 0x07)) {
        cout << "aa" << endl;
        /*
         * 如果我们在这里将宏当做函数的话 我们期望的展开是这样: (a & 0x0f) >= 0x07 ? 0 : 1
         * 但是其实传入的表达式是在宏的内部展开的:a & 0x0f >= 0x07 ? 0 : 1
         * 由于 & 优先级比 >= 小，所以这里就和我们的期望不符
         * 解决办法是 给宏内所有的参数都套上() ,这样能保证宏和函数一样的 运算优先级
         */
    }
}

//3. 但是就算2中有了解决办法，还有会有纰漏
#define BAND(x) (((x) > 5 && (x) < 10) ? (x) : 0)

int main() {
    ofstream out("macro.out");

    for (int i = 4; i < 11; ++i) {
        int a = 1;
        out << "a = " << a << endl << '\t';
        out << "BAND(++a) = " << BAND(++a) << endl;
        out << "\t a = " << a << endl;
    }
    /*
     * 正如我们在2中说的那样，传入宏的表达式是在 宏内展开的，所以就算我们将宏中全部的参数都用()包起来，
     * 还是会有不预期的展开:(((++a) > 5 && (++a) < 10) ? (++a) : 0),这里++a最多会被执行了三次，
     * 明显不是我们所预期的，其实归根到底 宏不能当成函数的原因就是:
     *
     * 函数在传入参的时候 传的是值，而宏只是将变量以入参的代码替换
     */
}

